<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="googlebot" content="NOODP" /><meta name="google-site-verification" content="nSYeDgyKM9mw5CWcZuD0xu7iSWXlJijAlg9rcxVOYf4" /><meta name="google-site-verification" content="6UEaC3SWhpGQvqRnSJIEm2swxXpM5Adn4dxZhFsNdw0" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="viewport" name="viewport" /><link href="https://fonts.googleapis.com/css?family=Raleway:400,500,600,700" rel="stylesheet" /><link rel="stylesheet" href="/css/rabbit.css" type="text/css" /><link rel="stylesheet" href="/css/highlightjs_style.css" type="text/css" /><!--[if IE 6]>
      <link rel="stylesheet" href="/css/rabbit-ie6.css" type="text/css" />
      <![endif]--><link rel="icon" type="/image/vnd.microsoft.icon" href="/favicon.ico" /><link rel="stylesheet" href="/css/tutorial.css" type="text/css" /><script type="text/javascript" src="/js/site.js"></script><script type="text/javascript" src="/js/ga-bootstrap.js"></script><title>RabbitMQ - Java Client API Guide</title>
        
    </head>
    <body id="api-guide"><div id="outerContainer"><div class="container"><div class="rabbit-logo"><a href="/"><img src="/img/RabbitMQ-logo.svg" alt="RabbitMQ" /></a></div><a class="btn menubtn" onclick="showHide()">Menu <img src="/img/carrot-down-white.svg" /></a><div class="mobilemenuicon" onclick="showHide()"><img src="/img/mobile-menu-icon.svg" /></div><div id="nav"><ul id="mainNav"><li><a href="/#features">Features</a></li><li><a href="/#getstarted">Get Started</a></li><li><a href="/#support">Support</a></li><li><a href="/#community">Community</a></li><li><a href="/documentation.html">Docs</a></li><li><a href="/blog/">Blog</a></li></ul></div></div><div class="nav-separator"></div><div id="innerContainer" class="container"><div id="left-content"><h1>Java Client API Guide</h1>
      <div class="docSection"><a name="intro" id="intro"></a>

        <p class="intro">
          This guide covers RabbitMQ Java client API. It is not, however, a tutorial. Those
          are <a href="getstarted.html">available in a different section</a>.
        </p>

        <p class="intro">
          5.x release series of this library require JDK 8, both for compilation and at runtime. On Android,
          this means only <a href="https://developer.android.com/guide/platform/j8-jack.html">Android 7.0 or later</a> versions are supported.

          4.x release series support JDK 6 and Android versions prior to 7.0.
        </p>

        <p class="intro">
          The library is <a href="https://github.com/rabbitmq/rabbitmq-java-client/">open-source</a>, and is triple-licensed under

          <ul>
            <li><a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache Public License 2.0</a></li>
            <li><a href="https://www.mozilla.org/MPL/1.1/">Mozilla Public License</a></li>
            <li><a href="http://www.gnu.org/licenses/gpl-2.0.html">GPL 2.0</a></li>
          </ul>

          This means that the user can consider the library to be licensed under any of the licenses from the list above.
          For example, the user may choose the Apache Public License 2.0 and include this client into
          a commercial product. Codebases that are licensed under the GPLv2 may choose GPLv2, and so on.
        </p>

        <p class="intro">
          An <a href="/releases/rabbitmq-java-client/current-javadoc/">API reference</a> (JavaDoc) is available separately.
        </p>

        <p class="intro">
          There are also <a href="java-tools.html">command line tools</a>
          that used to be shipped with the Java client.
        </p>

        <p>
          The client API is closely modelled on the AMQP 0-9-1 protocol specification,
          with additional abstractions for ease of use.
        </p>
    </div>

    <div class="docSection"><a name="classoverview" id="classoverview"></a>
      <h2 class="docHeading">Overview</h2>
      <p>
        RabbitMQ Java client uses <span class="code ">com.rabbitmq.client</span> as its top-level package.
        The key classes and interfaces are:

        <ul>
            <li>Channel</li>
            <li>Connection</li>
            <li>ConnectionFactory</li>
            <li>Consumer</li>
        </ul>

        Protocol operations are available through the
        <span class="code ">Channel</span> interface. <span class="code ">Connection</span> is
        used to open channels, register connection lifecycle event
        handlers, and close connections that are no longer needed.
        <span class="code ">Connection</span>s are instantiated through <span class="code ">ConnectionFactory</span>,
        which is how you configure various connection settings, such as the vhost or username.
      </p>
    </div>

    <div class="docSection"><a name="connecting" id="connecting"></a>
    <h2 class="docHeading">Connections and Channels</h2>

    <p>
            The core API classes are <span class="code ">Connection</span>
            and <span class="code ">Channel</span>, representing an AMQP 0-9-1 connection and an
            channel, respectively. They are typically imported before used:
    </p>
<pre class="sourcecode java">
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;
</pre>

    <h2 class="docHeading">Connecting to a broker</h2>

    <p>
        The following code connects to an AMQP broker using the given parameters (host name, port number, etc):
    </p>

<pre class="sourcecode java">
ConnectionFactory factory = new ConnectionFactory();
factory.setUsername(userName);
factory.setPassword(password);
factory.setVirtualHost(virtualHost);
factory.setHost(hostName);
factory.setPort(portNumber);
Connection conn = factory.newConnection();
</pre>

    <p>
        All of these parameters have sensible defaults for a RabbitMQ server running locally.
    </p>
    <p>
        Alternatively, <a href="uri-spec.html">URIs</a> may be used:
    </p>

<pre class="sourcecode java">
ConnectionFactory factory = new ConnectionFactory();
factory.setUri("amqp://userName:password@hostName:portNumber/virtualHost");
Connection conn = factory.newConnection();
</pre>

    <p>
        All of these parameters have sensible defaults for a stock
        RabbitMQ server running locally.
    </p>

        <p>
        The <span class="code ">Connection</span> interface can then be used to open a channel:
        </p>

<pre class="sourcecode java">
Channel channel = conn.createChannel();
</pre>
    <p>
        The channel can now be used to send and receive messages, as described in subsequent sections.
    </p>

    <p>
        To disconnect, simply close the channel and the connection:
    </p>

    <pre class="sourcecode java">channel.close();
conn.close();</pre>

    <p>
        Note that closing the channel may be considered good practice, but isn’t strictly necessary here - it will be done
        automatically anyway when the underlying connection is closed.
    </p>

  </div>


    <div class="docSection"><a name="exchanges-and-queues" id="exchanges-and-queues"></a>
      <h2 class="docHeading">Using Exchanges and Queues</h2>

      <p>
       Client applications work with exchanges and queues, the high-level building blocks of AMQP.
       These must be "declared" before they can be used. Declaring either type of object
       simply ensures that one of that name exists, creating it if necessary.
      </p>

      <p>
       Continuing the previous example, the following code declares an exchange and a queue,
       then binds them together.
      </p>

      <pre class="sourcecode java">channel.exchangeDeclare(exchangeName, "direct", true);
String queueName = channel.queueDeclare().getQueue();
channel.queueBind(queueName, exchangeName, routingKey);</pre>

      <p>
        This will actively declare the following objects,
        both of which can be customised by using additional parameters.
        Here neither of them have any special arguments.
      </p>

      <ol>
        <li>a durable, non-autodelete exchange of "direct" type</li>
        <li>a non-durable, exclusive, autodelete queue with a generated name</li>
      </ol>

      <p>
        The above function calls then bind the queue to the exchange with the
        given routing key.
      </p>
      <p>
        Note that this would be a typical way to declare a queue when only one
        client wants to work with it: it doesn’t need a well-known name, no
        other client can use it (exclusive) and will be cleaned up
        automatically (autodelete). If several clients want to share a queue
        with a well-known name, this code would be appropriate:
      </p>

      <pre class="sourcecode java">channel.exchangeDeclare(exchangeName, "direct", true);
channel.queueDeclare(queueName, true, false, false, null);
channel.queueBind(queueName, exchangeName, routingKey);</pre>

      <p>
        This will actively declare:
      </p>

      <ol>
        <li>a durable, non-autodelete exchange of "direct" type</li>
        <li>a durable, non-exclusive, non-autodelete queue with a well-known name</li>
      </ol>

      <p>
        Note that all of these <span class="code ">Channel</span> API methods are overloaded.
        These convenient short forms of <span class="code ">exchangeDeclare</span>, <span class="code ">queueDeclare</span> and <span class="code ">queueBind</span>
        use sensible defaults. There are also longer forms with more parameters, to let you override these defaults
        as necessary, giving full control where needed.
      </p>
      <p>
        This "short form, long form" pattern is used throughout the client API uses.
      </p>
    </div>

    <div class="docSection"><a name="publishing" id="publishing"></a>
      <h2 class="docHeading">Publishing messages</h2>

      <p>
        To publish a message to an exchange, use <span class="code ">Channel.basicPublish</span> as follows:
      </p>

      <pre class="sourcecode java">byte[] messageBodyBytes = "Hello, world!".getBytes();
channel.basicPublish(exchangeName, routingKey, null, messageBodyBytes);</pre>

      <p>
        For fine control, you can use overloaded variants to specify the <span class="code ">mandatory</span> flag,
        or send messages with pre-set message properties:
      </p>

      <pre class="sourcecode java">channel.basicPublish(exchangeName, routingKey, mandatory,
                     MessageProperties.PERSISTENT_TEXT_PLAIN,
                     messageBodyBytes);</pre>

      <p>
        This sends a message with delivery mode 2 (persistent), priority 1
        and content-type "text/plain". You can build your
        own message properties object, using a <span class="code ">Builder</span> class
        mentioning as many properties as you like, for example:
      </p>

      <pre class="sourcecode java">
channel.basicPublish(exchangeName, routingKey,
             new AMQP.BasicProperties.Builder()
               .contentType("text/plain")
               .deliveryMode(2)
               .priority(1)
               .userId("bob")
               .build()),
               messageBodyBytes);</pre>

      <p>
        This example publishes a message with custom headers:
      </p>

      <pre class="sourcecode java">
Map&lt;String, Object&gt; headers = new HashMap&lt;String, Object&gt;();
headers.put("latitude",  51.5252949);
headers.put("longitude", -0.0905493);

channel.basicPublish(exchangeName, routingKey,
             new AMQP.BasicProperties.Builder()
               .headers(headers)
               .build()),
               messageBodyBytes);</pre>

      <p>
        This example publishes a message with expiration:
      </p>

      <pre class="sourcecode java">
channel.basicPublish(exchangeName, routingKey,
             new AMQP.BasicProperties.Builder()
               .expiration("60000")
               .build()),
               messageBodyBytes);</pre>

      <p>
        We have not illustrated all the possibilities here.
      </p>
      <p>
        Note that <span class="code ">BasicProperties</span> is an inner class of the autogenerated
        holder class <span class="code ">AMQP</span>.
      </p>

      <p>
        Invocations of <span class="code ">Channel#basicPublish</span> will eventually block if a
        <a href="http://www.rabbitmq.com/alarms.html">resource-driven alarm</a> is in effect.
      </p>
    </div>

    <div class="docSection"><a name="channel-threads" id="channel-threads"></a>
      <h2 class="docHeading">Channels and Concurrency Considerations (Thread Safety)</h2>

      <p>
        As a rule of thumb, sharing <span class="code ">Channel</span> instances between
        threads is something to be avoided. Applications
        should prefer using a <span class="code ">Channel</span> per thread
        instead of sharing the same <span class="code ">Channel</span> across
        multiple threads.
      </p>
      <p>
        While some operations on channels are safe to invoke
        concurrently, some are not and will result in incorrect frame interleaving
        on the wire, double acknowledgements and so on.
      </p>
      <p>
        Concurrent publishing on a shared channel can result in
        incorrect frame interleaving on the wire, triggering a
        connection-level protocol exception and connection closure. It
        therefore requires explicit synchronization in application
        code (<span class="code ">Channel#basicPublish</span> must be invoked in a
        critical section). Sharing channels between threads will also
        interfere with <a href="confirms.html">Publisher
        Confirms</a>. We highly recommend avoiding concurrent
        publishing on a shared channel.
      </p>
      <p>
        Consuming in one thread and publishing in another thread on a shared channel
        can be safe.
      </p>
      <p>
        Server-pushed deliveries (see the section below) are
        dispatched concurrently with a guarantee that per-channel
        ordering is preserved.  The dispatch mechanism uses a <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html">java.util.concurrent.ExecutorService</a>,
        one per connection.  It is possible to provide a custom
        executor that will be shared by all connections produced by a
        single <span class="code ">ConnectionFactory</span> using the
        <span class="code ">ConnectionFactory#setSharedExecutor</span> setter.
      </p>
      <p>
        When <a href="confirms.html">manual acknowledgements</a> are used, it is important
        to consider what thread does the acknowledgement. If it's different from the
        thread that received the delivery (e.g. <span class="code ">Consumer#handleDelivery</span>
        delegated delivery handling to a different thread), acknowledging
        with the <span class="code ">multiple</span> parameter set to <span class="code ">true</span> is unsafe
        and will result in double-acknowledgements, and therefore a channel-level protocol
        exception that closes the channel. Acknowledging a single message at a time
        can be safe.
      </p>
    </div>

    <div class="docSection"><a name="consuming" id="consuming"></a>
      <h2 class="docHeading">Receiving Messages by Subscription ("Push API")</h2>

      <pre class="sourcecode java">import com.rabbitmq.client.Consumer;
import com.rabbitmq.client.DefaultConsumer;</pre>

      <p>
        The most efficient way to receive messages is to set up a
        subscription using the <span class="code ">Consumer</span>
        interface. The messages will then be delivered
        automatically as they arrive, rather than having to be
        explicitly requested.
      </p>

      <p>
        When calling the API methods relating to
        <span class="code ">Consumer</span>s, individual subscriptions are
        always referred to by their consumer tags. A consumer tag is a consumer
        identifier which can be either client- or server-generated. To let
        RabbitMQ generate a node-wide unique tag, use a <span class="code ">Channel#basicConsume</span> override
        that doesn't take a consumer tag argument or pass an empty string
        for consumer tag and use the value returned by <span class="code ">Channel#basicConsume</span>.
        Consumer tags are used to cancel consumers.
      </p>

      <p>
        Distinct <span class="code ">Consumer</span> instances must have distinct
        consumer tags. Duplicate consumer tags on a connection is
        strongly discouraged and can lead to issues with automatic
        connection recovery and confusing monitoring data when
        consumers are monitored.
      </p>

      <p>
        The easiest way to implement a <span class="code ">Consumer</span> is to
        subclass the convenience class <span class="code ">DefaultConsumer</span>.
        An object of this subclass can be passed on a <span class="code ">basicConsume</span>
        call to set up the subscription:
      </p>

      <pre class="sourcecode java">boolean autoAck = false;
channel.basicConsume(queueName, autoAck, "myConsumerTag",
     new DefaultConsumer(channel) {
         @Override
         public void handleDelivery(String consumerTag,
                                    Envelope envelope,
                                    AMQP.BasicProperties properties,
                                    byte[] body)
             throws IOException
         {
             String routingKey = envelope.getRoutingKey();
             String contentType = properties.getContentType();
             long deliveryTag = envelope.getDeliveryTag();
             <i>// (process the message components here ...)</i>
             channel.basicAck(deliveryTag, false);
         }
     });</pre>

      <p>
          Here, since we specified <span class="code ">autoAck = </span><span class="code ">false</span>,
          it is necessary to acknowledge messages delivered to the <span class="code ">Consumer</span>,
          most conveniently done in the <span class="code ">handleDelivery</span>
          method, as illustrated.
      </p>

      <p>
        More sophisticated <span class="code ">Consumer</span>s will need to override further
        methods.  In particular, <span class="code ">handleShutdownSignal</span>
        is called when channels and connections close, and
        <span class="code ">handleConsumeOk</span> is passed the consumer tag
        before any other callbacks to that <span class="code ">Consumer</span> are called.
      </p>

      <p>
        <span class="code ">Consumer</span>s can also implement the
        <span class="code ">handleCancelOk</span> and <span class="code ">handleCancel</span>
        methods to be notified of explicit and implicit cancellations,
        respectively.
      </p>

      <p>
        You can explicitly cancel a particular <span class="code ">Consumer</span> with
        <span class="code ">Channel.basicCancel</span>:
      </p>

      <pre class="sourcecode java">channel.basicCancel(consumerTag);</pre>

      <p>
        passing the consumer tag.
      </p>

      <p>
        Just like with publishers, it is important to consider concurrency
        hazard safety for consumers.
      </p>

      <p>
        Callbacks to <span class="code ">Consumer</span>s are dispatched in a thread
        pool separate from the thread that instantiated its
        <span class="code ">Channel</span>.  This means that <span class="code ">Consumer</span>s
        can safely call blocking methods on the
        <span class="code ">Connection</span> or <span class="code ">Channel</span>, such as
        <span class="code ">Channel#queueDeclare</span> or
        <span class="code ">Channel#basicCancel</span>.
      </p>

      <p>
        Each <span class="code ">Channel</span> has its own dispatch thread. For the
        most common use case of one <span class="code ">Consumer</span> per
        <span class="code ">Channel</span>, this means <span class="code ">Consumer</span>s do
        not hold up other <span class="code ">Consumer</span>s. If you have multiple
        <span class="code ">Consumer</span>s per <span class="code ">Channel</span> be aware that
        a long-running <span class="code ">Consumer</span> may hold up dispatch of
        callbacks to other <span class="code ">Consumer</span>s on that
        <span class="code ">Channel</span>.
      </p>

      <p>
        Please refer to the Concurrency Considerations (Thread Safety)
        section for other topics related to concurrency and
        concurrency hazard safety.
      </p>
    </div>

    <div class="docSection"><a name="getting" id="getting"></a>
      <h2 class="docHeading">Retrieving Individual Messages ("Pull API")</h2>

      <p>
        To explicitly retrieve messages, use
        <span class="code ">Channel.basicGet</span>.  The returned value is an
        instance of <span class="code ">GetResponse</span>, from which the
        header information (properties) and message body can be
        extracted:
      </p>
<pre class="sourcecode java">
boolean autoAck = false;
GetResponse response = channel.basicGet(queueName, autoAck);
if (response == null) {
    <i>// No message retrieved.
</i>} else {
    AMQP.BasicProperties props = response.getProps();
    byte[] body = response.getBody();
    long deliveryTag = response.getEnvelope().getDeliveryTag();
    ...</pre>

      <p>
        and since the <span class="code ">autoAck</span> = <span class="code ">false</span> above,
        you must also call <span class="code ">Channel.basicAck</span> to
        acknowledge that you have successfully received the message:
      </p>
<pre class="sourcecode java">
    ...
    channel.basicAck(method.deliveryTag, false); <i>// acknowledge receipt of the message</i>
}</pre>

    </div>

    <div class="docSection"><a name="returning" id="returning"></a>
      <h2 class="docHeading">Handling unroutable messages</h2>

      <p>
        If a message is published with the "mandatory" flags set,
        but cannot be routed, the broker will return it to the
        sending client (via a <span class="code ">AMQP.Basic.Return</span>
        command).
      </p>
      <p>
        To be notified of such returns, clients can implement the <span class="code ">ReturnListener</span>
        interface and call <span class="code ">Channel.addReturnListener</span>.
        If the client has not configured a return listener for a particular channel,
        then the associated returned messages will be silently dropped.
      </p>

<pre class="sourcecode java">
channel.addReturnListener(new ReturnListener() {
    public void handleReturn(int replyCode,
                                  String replyText,
                                  String exchange,
                                  String routingKey,
                                  AMQP.BasicProperties properties,
                                  byte[] body)
    throws IOException {
        ...
    }
});</pre>
      <p>
        A return listener will be called, for example, if the client publishes a message with
        the "mandatory" flag set to an exchange of "direct" type which is not bound to a queue.
      </p>
    </div>

      <div class="docSection"><a name="shutdown" id="shutdown"></a>
        <h2 class="docHeading">Shutdown Protocol</h2>
          <div class="docSubsection"><a name="shutdown-overview" id="shutdown-overview"></a>
        <h3 class="docHeading">Overview of the AMQP client shutdown</h3>
        <p>
          The AMQP 0-9-1 connection and channel share the same general
          approach to managing network failure, internal failure,
          and explicit local shutdown.
        </p>
        <p>
          The AMQP 0-9-1 connection and channel have the following lifecycle states:
        </p>
        <ul>
          <li>
        <span class="code ">open</span>: the object is ready to use
          </li>
          <li>
        <span class="code ">closing</span>: the object has been explicitly
        notified to shut down locally, has issued a shutdown
        request to any supporting lower-layer objects, and is
        waiting for their shutdown procedures to complete
          </li>
          <li>
        <span class="code ">closed</span>: the object has received all
        shutdown-complete notification(s) from any lower-layer
        objects, and as a consequence has shut itself down
          </li>
        </ul>
        <p>
          Those objects always end up in the closed state,
          regardless of the reason that caused the closure, like
          an application request, an internal client library
          failure, a remote network request or network failure.
        </p>
        <p>
          The AMQP connection and channel objects possess the
          following shutdown-related methods:
        </p>
        <ul>
          <li>

        <span class="code ">addShutdownListener(ShutdownListener listener)</span> and

        <span class="code ">removeShutdownListener(ShutdownListener listener)</span>, to manage any listeners, which will
        be fired when the object transitions to
        <span class="code ">closed</span> state. Note that, adding a
        ShutdownListener to an object that is already closed
        will fire the listener immediately
          </li>
          <li>
        <span class="code ">getCloseReason()</span>, to allow the
        investigation of what was the reason of the object’s
        shutdown
          </li>
          <li>
        <span class="code ">isOpen()</span>, useful for testing whether the
        object is in an open state
          </li>
          <li>

        <span class="code ">close(int closeCode, String closeMessage)</span>, to explicitly notify the object
        to shut down
          </li>
        </ul>
        <p>
          Simple usage of listeners would look like:
        </p>
            <pre class="sourcecode java">import com.rabbitmq.client.ShutdownSignalException;
import com.rabbitmq.client.ShutdownListener;

connection.addShutdownListener(new ShutdownListener() {
    public void shutdownCompleted(ShutdownSignalException cause)
    {
        ...
    }
});</pre>
      </div>
      <div class="docSubsection"><a name="shutdown-cause" id="shutdown-cause"></a>
        <h3 class="docHeading">Information about the circumstances of a shutdown</h3>
        <p>
          One can retrieve the
          <span class="code ">ShutdownSignalException</span>, which contains all
          the information available about the close reason, either
          by explicitly calling the <span class="code ">getCloseReason()</span>
          method or by using the <span class="code ">cause</span> parameter in
          the <span class="code ">service(ShutdownSignalException cause)</span>
          method of the <span class="code ">ShutdownListener</span> class.
        </p>
        <p>
          The <span class="code ">ShutdownSignalException</span> class provides
          methods to analyze the reason of the shutdown. By
          calling the <span class="code ">isHardError()</span> method we get
          information whether it was a connection or a channel
          error, and <span class="code ">getReason()</span> returns information
          about the cause, in the form an AMQP method - either
          <span class="code ">AMQP.Channel.Close</span> or
          <span class="code ">AMQP.Connection.Close</span> (or null if the cause
          was some exception in the library, such as a network
          communication failure, in which case that exception can
          be retrieved with <span class="code ">getCause()</span>).
        </p>
            <pre class="sourcecode java">public void shutdownCompleted(ShutdownSignalException cause)
{
  if (cause.isHardError())
  {
    Connection conn = (Connection)cause.getReference();
    if (!cause.isInitiatedByApplication())
    {
      Method reason = cause.getReason();
      ...
    }
    ...
  } else {
    Channel ch = (Channel)cause.getReference();
    ...
  }
}</pre>
          </div>
          <div class="docSubsection"><a name="shutdown-atomicity" id="shutdown-atomicity"></a>
            <h3 class="docHeading">Atomicity and use of the isOpen() method</h3>
            <p>
             Use of the <span class="code ">isOpen()</span> method of channel and
             connection objects is not recommended for production
             code, because the value returned by the method is
             dependent on the existence of the shutdown cause.  The
             following code illustrates the possibility of race
             conditions:
        </p>
        <pre class="sourcecode java">public void brokenMethod(Channel channel)
{
    if (channel.isOpen())
    {
        // The following code depends on the channel being in open state.
        // However there is a possibility of the change in the channel state
        // between isOpen() and basicQos(1) call
        ...
        channel.basicQos(1);
    }
}</pre>
        <p>
          Instead, we should normally ignore such checking, and
          simply attempt the action desired. If during the
          execution of the code the channel of the connection is
          closed, a <span class="code ">ShutdownSignalException</span> will be
          thrown indicating that the object is in an invalid
          state. We should also catch for <span class="code ">IOException</span>
          caused either by <span class="code ">SocketException</span>, when
          broker closes the connection unexpectedly, or
          <span class="code ">ShutdownSignalException</span>, when broker
          initiated clean close.
        </p>
        <pre class="sourcecode java">public void validMethod(Channel channel)
{
    try {
        ...
        channel.basicQos(1);
    } catch (ShutdownSignalException sse) {
        // possibly check if channel was closed
        // by the time we started action and reasons for
        // closing it
        ...
    } catch (IOException ioe) {
        // check why connection was closed
        ...
    }
}</pre>
          </div>
    </div>


<div class="docSection"><a name="advanced-connection" id="advanced-connection"></a>
  <h2 class="docHeading">Advanced Connection options</h2>
    <div class="docSubsection"><a name="consumer-thread-pool" id="consumer-thread-pool"></a>
        <h3 class="docHeading"><i>Consumer thread pool</i></h3>
        <p>
          <span class="code ">Consumer</span> threads (see <a href="#consuming">Receiving</a> below) are
          automatically allocated in a new <span class="code ">ExecutorService</span> thread pool
          by default. If greater control is required supply an <span class="code ">ExecutorService</span> on the
          <span class="code ">newConnection()</span> method, so that this pool of threads is
          used instead. Here is an example where a larger thread pool is
          supplied than is normally allocated:
<pre class="sourcecode java">
ExecutorService es = Executors.newFixedThreadPool(20);
Connection conn = factory.newConnection(es);
</pre>
          Both <span class="code ">Executors</span> and <span class="code ">ExecutorService</span> classes
          are in the <span class="code ">java.util.concurrent</span> package.
        </p>
        <p>
          When the connection is closed a default <span class="code ">ExecutorService</span>
          will be <span class="code ">shutdown()</span>, but a user-supplied
          <span class="code ">ExecutorService</span> (like <span class="code ">es</span> above) will
          <i>not</i> be <span class="code ">shutdown()</span>.
          Clients that supply a custom <span class="code ">ExecutorService</span> must ensure
          it is shutdown eventually (by calling its <span class="code ">shutdown()</span>
          method), or else the pool’s threads may prevent JVM termination.
        </p>
        <p>
          The same executor service may be shared between multiple connections,
          or serially re-used on re-connection but it cannot be used after it is
          <span class="code ">shutdown()</span>.
        </p>
        <p>
          Use of this feature should only be considered if there is evidence
          that there is a severe bottleneck in the processing of <span class="code ">Consumer</span>
          callbacks.
          If there are no <span class="code ">Consumer</span> callbacks executed, or very few, the default
          allocation is more than sufficient. The overhead is initially minimal and
          the total thread resources allocated are bounded, even if a burst of consumer
          activity may occasionally occur.
        </p>
    </div>

    <div class="docSubsection"><a name="address-array" id="address-array"></a>
        <h3 class="docHeading">Using Lists of Hosts</h3>
        <p>
          It is possible to pass an <span class="code ">Address</span> array
          to <span class="code ">newConnection()</span>.
          An <span class="code ">Address</span> is simply a convenience class
          in the <span class="code ">com.rabbitmq.client</span> package with <i>host</i>
          and <i>port</i> components.
          For example:
<pre class="sourcecode java">
Address[] addrArr = new Address[]{ new Address(hostname1, portnumber1)
                                 , new Address(hostname2, portnumber2)};
Connection conn = factory.newConnection(addrArr);
</pre>
          will attempt to connect to <span class="code ">hostname1:portnumber1</span>, and if
          that fails to <span class="code ">hostname2:portnumber2</span>. The connection returned is
          the first in the array that succeeds (without throwing
          <span class="code ">IOException</span>). This is entirely equivalent to repeatedly
          setting host and port on a factory, calling
          <span class="code ">factory.newConnection()</span> each time, until one of them succeeds.
        </p>
        <p>
          If an <span class="code ">ExecutorService</span> is provided as well (using the
          form <span class="code ">factory.newConnection(es, addrArr)</span>) the thread pool is
          associated with the (first) successful connection.
        </p>
        <p>
          If you want more control over the host to connect to, see
          <a href="#service-discovery-with-address-resolver">
          the support for service discovery</a>.
        </p>
    </div>

    <div class="docSubsection"><a name="service-discovery-with-address-resolver" id="service-discovery-with-address-resolver"></a>
        <h3 class="docHeading">Service discovery with the AddressResolver interface</h3>
        <p>
          As of version 3.6.6, it is possible to let an implementation of
          <span class="code ">AddressResolver</span> choose where to connect when creating a connection:
<pre class="sourcecode java">
Connection conn = factory.newConnection(addressResolver);
</pre>
        The <span class="code ">AddressResolver</span> interface is like the following:
<pre class="sourcecode java">
public interface AddressResolver {

  List&lt;Address&gt; getAddresses() throws IOException;

}
</pre>
          Just like with <a href="#address-array">a list of hosts</a>,
          the first <span class="code ">Address</span> returned will be tried first, then
          the second if the client fails to connect to the first, and so on.
        </p>
        <p>
          If an <span class="code ">ExecutorService</span> is provided as well (using the
          form <span class="code ">factory.newConnection(es, addressResolver)</span>) the thread pool is
          associated with the (first) successful connection.
        </p>
        <p>
          The <span class="code ">AddressResolver</span> is the perfect place to implement
          custom service discovery logic, which is especially useful in a dynamic
          infrastructure. Combined with <a href="#recovery">automatic recovery</a>,
          the client can automatically connect to nodes that weren't even up
          when it was first started. Affinity and load balancing are other
          scenarios where a custom <span class="code ">AddressResolver</span> could be useful.
        </p>
        <p>
          The Java client ships with the following implementations
          (see the javadoc for details):
          <ol>
            <li>
              <span class="code ">DnsRecordIpAddressResolver</span>: given the name
              of a host, returns its IP addresses (resolution against
              the platform DNS server). This can be useful for simple
              DNS-based load balancing or failover.
            </li>
            <li>
              <span class="code ">DnsSrvRecordAddressResolver</span>: given the name
              of a service, returns hostname/port pairs. The search is
              implemented as a DNS SRV request. This can be useful
              when using a service registry like
              <a href="https://www.consul.io/">HashiCorp Consul</a>.
            </li>
          </ol>
        </p>
    </div>

    <div class="docSubsection"><a name="heartbeats-timeout" id="heartbeats-timeout"></a>
        <h3 class="docHeading">Heartbeat Timeout</h3>
        <p>See the <a href="heartbeats.html">Heartbeats guide</a> for more information about heartbeats
        and how to configure them in the Java client.</p>
    </div>

    <div class="docSubsection"><a name="thread-factories" id="thread-factories"></a>
      <h3 class="docHeading"><i>Custom Thread Factories</i></h3>
      <p>
        Environments such as Google App Engine (GAE) can <a href="https://developers.google.com/appengine/docs/java/#Java_The_sandbox">restrict
        direct thread instantiation</a>. To use RabbitMQ Java client in such environments,
        it's necessary to configure a custom <span class="code ">ThreadFactory</span> that uses
        an appropriate method to instantiate threads, e.g. GAE's <span class="code ">ThreadManager</span>.

        Below is an example for Google App Engine.
      </p>
      <p>
<pre class="sourcecode java">
import com.google.appengine.api.ThreadManager;

ConnectionFactory cf = new ConnectionFactory();
cf.setThreadFactory(ThreadManager.backgroundThreadFactory());
</pre>
      </p>
    </div>
    <div class="docSubsection"><a name="java-nio" id="java-nio"></a>
      <h3 class="docHeading">Support for Java non-blocking IO</h3>
      <p>
        Version 4.0 of the Java client brings <i>experimental</i> support for Java non-blocking
        IO (a.k.a Java NIO). NIO isn't supposed to be faster than blocking IO,
        it simply allows to control resources (in this case, threads) more easily.
      </p>
      <p>
        With the default blocking IO mode, each connection uses a thread to read
        from the network socket. With the NIO mode, you can control the number of
        threads that read and write from/to the network socket.
      </p>
      <p>
        Use the NIO mode if your Java process uses many connections (dozens or hundreds).
        You should use fewer threads than with the default blocking mode. With the
        appropriate number of threads set, you shouldn't
        experiment any decrease in performance, especially if the connections are
        not so busy.
      </p>
      <p>
        NIO must be enabled explicitly:
      </p>
      <p>
<pre class="sourcecode java">
ConnectionFactory connectionFactory = new ConnectionFactory();
connectionFactory.useNio();
</pre>
      </p>
      <p>
        The NIO mode can be configured through the <span class="code ">NioParams</span> class:
      </p>
      <p>
<pre class="sourcecode java">
connectionFactory.setNioParams(new NioParams().setNbIoThreads(4));
</pre>
      </p>
      <p>
        The NIO mode uses reasonable defaults, but you may need to change them according
        to your own workload. Some of the settings are: the total number of IO
        threads used, the size of buffers, a service executor to use for the IO loops,
        parameters for the in-memory write queue (write requests are enqueued before
        being sent on the network). Please read the Javadoc for details and defaults.
      </p>
    </div>
</div>


    <div class="docSection"><a name="recovery" id="recovery"></a>
      <h2 class="docHeading">Automatic Recovery From Network Failures</h2>
      <div class="docSubsection"><a name="connection-recovery" id="connection-recovery"></a>
        <h3 class="docHeading">Connection Recovery</h3>
        <p>
          Network connection between clients and RabbitMQ nodes can fail.
          RabbitMQ Java client supports automatic recovery of connections
          and topology (queues, exchanges, bindings, and consumers).

          The automatic recovery process for many applications follows the following steps:
          <ol>
            <li>Reconnect</li>
            <li>Restore connection listeners</li>
            <li>Re-open channels</li>
            <li>Restore channel listeners</li>
            <li>Restore channel <span class="code ">basic.qos</span> setting, publisher confirms and transaction settings</li>
          </ol>

          Topology recovery includes the following actions, performed for every channel

          <ol>
            <li>Re-declare exchanges (except for predefined ones)</li>
            <li>Re-declare queues</li>
            <li>Recover all bindings</li>
            <li>Recover all consumers</li>
          </ol>

          <em>As of version 4.0.0 of the Java client, automatic recovery is enabled
          by default (and thus topology recovery as well)</em>.
        </p>
        <p>
          To disable or enable automatic connection recovery, use
          the <span class="code ">factory.setAutomaticRecoveryEnabled(boolean)</span>
          method. The following snippet shows how to explicitly
          enable automatic recovery (e.g. for Java client prior 4.0.0):
          <pre class="sourcecode java">
ConnectionFactory factory = new ConnectionFactory();
factory.setUsername(userName);
factory.setPassword(password);
factory.setVirtualHost(virtualHost);
factory.setHost(hostName);
factory.setPort(portNumber);
factory.setAutomaticRecoveryEnabled(true);
// connection that will recover automatically
Connection conn = factory.newConnection();</pre>

          If recovery fails due to an exception (e.g. RabbitMQ node is
          still not reachable), it will be retried after a fixed time interval (default
          is 5 seconds). The interval can be configured:

          <pre class="sourcecode java">
ConnectionFactory factory = new ConnectionFactory();
// attempt recovery every 10 seconds
factory.setNetworkRecoveryInterval(10000);</pre>

          When a list of addresses is provided, the list is shuffled and
          all addresses are tried, one after the next:

          <pre class="sourcecode java">
ConnectionFactory factory = new ConnectionFactory();

Address[] addresses = {new Address("192.168.1.4"), new Address("192.168.1.5")};
factory.newConnection(addresses);</pre>
        </p>
      </div>

      <div class="docSubsection"><a name="recovery-listeners" id="recovery-listeners"></a>
        <h3 class="docHeading">Recovery Listeners</h3>
        <p>
          It is possible to register one or more recovery listeners on recoverable connections
          and channels. When connection recovery is enabled, connections returned by
          <span class="code ">ConnectionFactory#newConnection</span> and <span class="code ">Connection#createChannel</span>
          implement <span class="code ">com.rabbitmq.client.Recoverable</span>, providing two methods with
          fairly descriptive names:

          <ul>
            <li>addRecoveryListener</li>
            <li>removeRecoveryListener</li>
          </ul>

          Note that you currently need to cast connections and channels to <span class="code ">Recoverable</span>
          in order to use those methods.
        </p>
      </div>


      <div class="docSubsection"><a name="publishers" id="publishers"></a>
        <h3 class="docHeading">Effects on Publishing</h3>
        <p>
          Messages that are published using <span class="code ">Channel.basicPublish</span> when connection is down
          will be lost. The client does not enqueue them for delivery after connection has recovered.
          To ensure that published messages reach RabbitMQ applications need to use <a href="confirms.html">Publisher Confirms</a>
          and account for connection failures.
        </p>
      </div>

      <div class="docSubsection"><a name="topology-recovery" id="topology-recovery"></a>
        <h3 class="docHeading">Topology Recovery</h3>
        <p>
          Topology recovery involves recovery of exchanges, queues, bindings
          and consumers. It is enabled by default when automatic recovery is
          enabled. <em>Hence topology recovery is enabled by default as of
          Java client 4.0.0</em>.
        </p>
        <p>
          Topology recovery can be disabled explicitly if needed:
          <pre class="sourcecode java">
ConnectionFactory factory = new ConnectionFactory();

Connection conn = factory.newConnection();
// enable automatic recovery (e.g. Java client prior 4.0.0)
factory.setAutomaticRecoveryEnabled(true);
// disable topology recovery
factory.setTopologyRecoveryEnabled(false);
          </pre>
        </p>
        </div>

        <div class="docSubsection"><a name="automatic-recovery-limitations" id="automatic-recovery-limitations"></a>
          <h3 class="docHeading">Failure Detection and Recovery Limitations</h3>
          <p>
            Automatic connection recovery has a number of limitations and intentional
            design decisions that applications developers need to be aware of.
          </p>
          <p>
            When a connection is down or lost, it <a href="/heartbeats.html">takes time to detect</a>.
            Therefore there is a window of time in which both the
            library and the application are unaware of effective
            connection failure.  Any messages published during this
            time frame are serialised and written to the TCP socket
            as usual. Their delivery to the broker can only be
            guaranteed via <a href="/confirms.html">publisher
            confirms</a>: publishing in AMQP 0-9-1 is entirely
            asynchronous by design.
          </p>
          <p>
            When a socket or I/O operation error is detected by a
            connection with automatic recovery enabled, recovery
            begins after a configurable delay, 5 seconds by
            default. This design assumes that even though a lot of
            network failures are transient and generally short
            lived, they do not go away in an instant. Connection recovery
            attempts will continue at identical time intervals until
            a new connection is successfully opened.
          </p>
          <p>
            When a connection is in the recovering state, any
            publishes attempted on its channels will be rejected
            with an exception. The client currently does not perform
            any internal buffering of such outgoing messages. It is
            an application developer's responsibility to keep track of such
            messages and republish them when recovery succeeds.
            <a href="/confirms.html">Publisher confirms</a> is a protocol extension
            that should be used by publishers that cannot afford message loss.
          </p>
          <p>
            Connection recovery will not kick in when a channel is closed due to a
            channel-level exception. Such exceptions often indicate application-level
            issues. The library cannot make an informed decision about when that's
            the case.
          </p>
          <p>
            Closed channels won't be recovered even after connection recovery kicks in.
            This includes both explicitly closed channels and the channel-level exception
            case above.
          </p>
        </div>

      <div class="docSubsection"><a name="recovery-and-acknowledgements" id="recovery-and-acknowledgements"></a>
        <h3 class="docHeading">Manual Acknowledgements and Automatic Recovery</h3>
        <p>
          When manual acknowledgements are used, it is possible that
          network connection to RabbitMQ node fails between message
          delivery and acknowledgement. After connection recovery,
          RabbitMQ will reset delivery tags on all channels.

          This means that <i>basic.ack</i>, <i>basic.nack</i>, and <i>basic.reject</i>
          with old delivery tags will cause a channel exception. To avoid this,
          RabbitMQ Java client keeps track of and updates delivery tags to make them monotonically
          growing between recoveries.

          <span class="code ">Channel.basicAck</span>,
          <span class="code ">Channel.basicNack</span>, and
          <span class="code ">Channel.basicReject</span> then translate adjusted
          delivery tags into those used by RabbitMQ.

          Acknowledgements with stale delivery tags will not be sent. Applications
          that use manual acknowledgements and automatic recovery must
          be capable of handling redeliveries.
        </p>
      </div>
    </div>

    <div class="docSection"><a name="unhandled-exceptions" id="unhandled-exceptions"></a>
      <h2 class="docHeading">Unhandled Exceptions</h2>
      <p>
        Unhandled exceptions related to connection, channel, recovery,
        and consumer lifecycle are delegated to the exception
        handler. Exception handler is any object that implements the
        <span class="code ">ExceptionHandler</span> interface.  By default, an
        instance of <span class="code ">DefaultExceptionHandler</span> is used. It
        prints exception details to the standard output.
      </p>

      <p>
        It is possible to override the handler using
        <span class="code ">ConnectionFactory#setExceptionHandler</span>. It will be
        used for all connections created by the factory:

        <pre class="sourcecode java">
ConnectionFactory factory = new ConnectionFactory();
cf.setExceptionHandler(customHandler);
        </pre>

        Exception handlers should be used for exception logging.
      </p>
    </div>

    <div class="docSection"><a name="metrics" id="metrics"></a>
      <h2 class="docHeading">Metrics and monitoring</h2>
      <p>
        As of version 4.0.0, the client gathers runtime metrics (e.g. number
        of published messages). Metrics collection is optional and is set up
        at the <span class="code ">ConnectionFactory</span> level, using the
        <span class="code ">setMetricsCollector(metricsCollector)</span> method.
        This method expects a <span class="code ">MetricsCollector</span> instance, which is
        called in several places of the client code.
      </p>
      <p>
          The client supports
          <a href="http://micrometer.io">Micrometer</a> (as of version 4.3) and
          <a href="http://metrics.dropwizard.io">Dropwizard Metrics</a>
          out of the box.
      </p>
        <p>
            Here are the collected metrics:
            <ul>
                <li>
                    Number of open connections
                </li>
                <li>
                    Number of open channels
                </li>
                <li>
                    Number of published messages
                </li>
                <li>
                    Number of consumed messages
                </li>
                <li>
                    Number of acknowledged messages
                </li>
                <li>
                    Number of rejected messages
                </li>
            </ul>
        </p>
        <p>
            Both Micrometer and Dropwizard Metrics provide counts, but also
            mean rate, last five minute rate, etc, for messages-related
            metrics. They also support common tools for monitoring and reporting
            (JMX, Graphite, Ganglia, Datadog, etc). See the dedicated
            sections below for more details.
        </p>
        <p>
            Please note the following about metrics collection:

            <ul>
                <li>
                    Don't forget to add the appropriate dependencies (in Maven, Gradle, or even as JAR files) to JVM
                    classpath when using Micrometer or Dropwizard Metrics.
                    Those are optional dependencies and will not be pulled automatically with the Java client.
                    You may also need to add other dependencies depending on the reporting
                    backend(s) used.
                </li>
                <li>
                    Metrics collection is extensible. Implementing a custom
                    <span class="code ">MetricsCollector</span> for specific needs is encouraged.
                </li>
                <li>
                    The <span class="code ">MetricsCollector</span> is set at the <span class="code ">ConnectionFactory</span>
                    level but can be shared across different instances.
                </li>
                <li>
                    Metrics collection doesn't support transactions. E.g. if an acknowledgment
                    is sent in a transaction and the transaction is then rolled back,
                    the acknowledgment is counted in the client metrics (but not by the broker
                    obviously). Note the acknowledgment is actually sent to the broker and
                    then cancelled by the transaction rollback, so the client metrics
                    are correct in term of acknowledgments sent. As a summary, don't use
                    client metrics for critical business logic, they're not guaranteed
                    to be perfectly accurate. They are meant to be used to simplify reasoning
                    about a running system and make operations more efficient.
                </li>
            </ul>
        </p>

      <div class="docSubsection"><a name="metrics-micrometer" id="metrics-micrometer"></a>
        <h3 class="docHeading">Micrometer support</h3>

          <p>
             You can enable metrics collection with
             <a href="http://micrometer.io">Micrometer</a> the following way:

<pre class="sourcecode java">
ConnectionFactory connectionFactory = new ConnectionFactory();
MicrometerMetricsCollector metrics = new MicrometerMetricsCollector();
connectionFactory.setMetricsCollector(metrics);
...
metrics.getPublishedMessages(); // get Micrometer's Counter object
</pre>

          </p>
          <p>
              Micrometer supports
              <a href="http://micrometer.io/docs">several reporting backends</a>:
              Netflix Atlas, Prometheus, Datadog, Influx, JMX, etc.
          </p>

          <p>
              You would typically pass in an instance of <span class="code ">MeterRegistry</span>
              to the <span class="code ">MicrometerMetricsCollector</span>. Here is an example
              with JMX:

<pre class="sourcecode java">
JmxMeterRegistry registry = new JmxMeterRegistry();
MicrometerMetricsCollector metrics = new MicrometerMetricsCollector(registry);

ConnectionFactory connectionFactory = new ConnectionFactory();
connectionFactory.setMetricsCollector(metrics);
</pre>

          </p>

      </div>

      <div class="docSubsection"><a name="metrics-dropwizard-metrics" id="metrics-dropwizard-metrics"></a>
        <h3 class="docHeading">Dropwizard Metrics support</h3>

          <p>
              You can enable metrics collection with
              <a href="http://metrics.dropwizard.io">Dropwizard</a> the following way:

<pre class="sourcecode java">
ConnectionFactory connectionFactory = new ConnectionFactory();
StandardMetricsCollector metrics = new StandardMetricsCollector();
connectionFactory.setMetricsCollector(metrics);
...
metrics.getPublishedMessages(); // get Metrics' Meter object
</pre>
          </p>

        <p>
          Dropwizard Metrics supports
          <a href="http://metrics.dropwizard.io/3.2.3/getting-started.html">several reporting backends</a>:
          console, JMX, HTTP, Graphite, Ganglia, etc.
        </p>

        <p>
          You would typically pass in an instance of <span class="code ">MetricsRegistry</span>
          to the <span class="code ">StandardMetricsCollector</span>. Here is an example
          with JMX:

          <pre class="sourcecode java">
MetricRegistry registry = new MetricRegistry();
StandardMetricsCollector metrics = new StandardMetricsCollector(registry);

ConnectionFactory connectionFactory = new ConnectionFactory();
connectionFactory.setMetricsCollector(metrics);

JmxReporter reporter = JmxReporter
  .forRegistry(registry)
  .inDomain("com.rabbitmq.client.jmx")
  .build();
reporter.start();
          </pre>

        </p>

      </div>

    </div>

    <div class="docSection"><a name="gae-pitfalls" id="gae-pitfalls"></a>
      <h2 class="docHeading">RabbitMQ Java Client on Google App Engine</h2>
      <p>
        Using RabbitMQ Java client on Google App Engine (GAE) requires using a custom
        thread factory that instantiates thread using GAE's <span class="code ">ThreadManager</span> (see above).
        In addition, it is necessary to set a low heartbeat interval (4-5 seconds) to avoid running
        into the low <span class="code ">InputStream</span> read timeouts on GAE:

        <pre class="sourcecode java">
ConnectionFactory factory = new ConnectionFactory();
cf.setRequestedHeartbeat(5);
        </pre>
      </p>
    </div>

    <div class="docSection"><a name="cache-pitfalls" id="cache-pitfalls"></a>
      <h2 class="docHeading">Caveats and Limitations</h2>
      <p>
        To make topology recovery possible, RabbitMQ Java client maintains a cache
        of declared queues, exchanges, and bindings. The cache is per-connection. Certain
        RabbitMQ features make it impossible for clients to observe some topology changes,
        e.g. when a queue is deleted due to TTL. RabbitMQ Java client tries to invalidate
        cache entries in the most common cases:

        <ul>
          <li>When queue is deleted.</li>
          <li>When exchange is deleted.</li>
          <li>When binding is deleted.</li>
          <li>When consumer is cancelled on an auto-deleted queue.</li>
          <li>When queue or exchange is unbound from an auto-deleted exchange.</li>
        </ul>

        However, the client cannot track these topology changes beyond a single connection.
        Applications that rely on auto-delete queues or exchanges, as well as queue TTL (note: not message TTL!),
        and use automatic connection recovery, should explicitly delete entities know to be unused
        or deleted, to purge client-side topology cache. This is facilitated by <span class="code ">Channel#queueDelete</span>,
        <span class="code ">Channel#exchangeDelete</span>, <span class="code ">Channel#queueUnbind</span>, and <span class="code ">Channel#exchangeUnbind</span>
        being idempotent in RabbitMQ 3.3.x (deleting what's not there does not result in an exception).
      </p>
    </div>


      <div class="docSection"><a name="rpc" id="rpc"></a>
    <h2 class="docHeading">The RPC (Request/Reply) Pattern</h2>

    <p>
      As a programming convenience, the Java client API offers a
      class <span class="code ">RpcClient</span> which uses a temporary reply
      queue to provide simple <a href="/tutorials/tutorial-six-java.html">RPC-style communication</a> facilities via AMQP 0-9-1.
    </p>
    <p>
      The class doesn’t impose any particular format on the RPC arguments and return values.
      It simply provides a mechanism for sending a message to a given exchange with a particular
      routing key, and waiting for a response on a reply queue.
    </p>

    <pre class="sourcecode java">
import com.rabbitmq.client.RpcClient;

RpcClient rpc = new RpcClient(channel, exchangeName, routingKey);</pre>

    <p>
      (The implementation details of how this class uses AMQP 0-9-1 are as follows: request messages are sent with the
      <span class="code ">basic.correlation_id</span> field set to a value unique for this <span class="code ">RpcClient</span> instance,
      and with <span class="code ">basic.reply_to</span> set to the name of the reply queue.)
    </p>

    <p>
      Once you have created an instance of this class, you can use it to send RPC requests by using any of the following methods:
    </p>

    <pre class="sourcecode java">byte[] primitiveCall(byte[] message);
String stringCall(String message)
Map mapCall(Map message)
Map mapCall(Object[] keyValuePairs)</pre>

    <p>
      The <span class="code ">primitiveCall</span> method transfers raw byte arrays as the request and response
      bodies. The method <span class="code ">stringCall</span> is a thin
      convenience wrapper around <span class="code ">primitiveCall</span>,
      treating the message bodies as <span class="code ">String</span> instances
      in the default character encoding.
    </p>
    <p>
      The <span class="code ">mapCall</span> variants are a little more sophisticated: they encode
      a <span class="code ">java.util.Map</span> containing ordinary Java values
      into an AMQP 0-9-1 binary table representation, and decode the
      response in the same way. (Note that there are some restrictions on what value
      types can be used here - see the javadoc for details.)
    </p>

    <p>
      All the marshalling/unmarshalling convenience methods use <span class="code ">primitiveCall</span> as a
      transport mechanism, and just provide a wrapping layer on top of it.
    </p>
      </div>

    <div class="docSection"><a name="tls" id="tls"></a>
    <h2 class="docHeading">TLS Support</h2>

        <p>
            It's possible to encrypt the communication between the client and the broker
            <a href="/ssl.html">using TLS</a>. Client and server authentication (a.k.a. peer verification) is also supported.
            Here is the simplest way to use encryption with the Java client:
        </p>

        <pre class="sourcecode">
ConnectionFactory factory = new ConnectionFactory();
factory.setHost("localhost");
factory.setPort(5671);

factory.useSslProtocol();
        </pre>

        <p>
            Note the client doesn't enforce any server authentication (peer certificate chain verification) in the above
            sample as the default, "trust all certificates" <span class="code ">TrustManager</span> is used.
            This is convenient for local development but prone to man-in-the-middle attacks
            and therefore not recommended for production.
            To learn more about TLS support in RabbitMQ, see
            the <a href="ssl.html">TLS guide</a>. If you only want to configure
            the Java client (especially the peer verification and trust manager parts),
            read <a href="ssl.html#trust-levels">the appropriate section</a> of the TLS guide.
        </p>
    </div>

  </div><div id="right-nav"><div id="in-this-section"><h4>In This Section</h4><ul>
     <li><a href="/admin-guide.html">Server Documentation</a></li>
     <li><a href="/clients.html" class="selected">Client Documentation</a><ul>
       <li><a href="/api-guide.html" class="selected">Java Client Guide</a><ul>
         <li><a href="/java-tools.html">Java Client Tools</a></li>
         
       </ul></li>
       <li><a href="/jms-client.html">JMS Client</a></li>
       <li><a href="/dotnet-api-guide.html">.NET Client Guide</a></li>
       <li><a href="/erlang-client-user-guide.html">Erlang Client Guide</a></li>
       <li><a href="/heartbeats.html">Heartbeats</a></li>
       <li><a href="/amqp-0-9-1-reference.html">AMQP 0-9-1 Reference</a></li>
       <li><a href="/uri-spec.html">AMQP 0-9-1 URI Spec</a></li>
       
       
       
     </ul></li>
     <li><a href="/plugins.html">Plugins</a></li>
     <li><a href="/news.html">News</a></li>
     <li><a href="/protocol.html">Protocol</a></li>
     <li><a href="/extensions.html">Our Extensions</a></li>
     <li><a href="/build.html">Building</a></li>
     
       <li><a href="/previous.html">Previous Releases</a></li>
     
     <li><a href="/mpl.html">License</a></li>
   </ul></div><div class="in-this-page"><h4>In This Page</h4><ul><li><a href="#intro"></a></li><li><a href="#classoverview">Overview</a></li><li><a href="#connecting">Connections and Channels</a></li><li><a href="#exchanges-and-queues">Using Exchanges and Queues</a></li><li><a href="#publishing">Publishing messages</a></li><li><a href="#channel-threads">Channels and Concurrency Considerations (Thread Safety)</a></li><li><a href="#consuming">Receiving Messages by Subscription ("Push API")</a></li><li><a href="#getting">Retrieving Individual Messages ("Pull API")</a></li><li><a href="#returning">Handling unroutable messages</a></li><li><a href="#shutdown">Shutdown Protocol</a></li><li><a href="#advanced-connection">Advanced Connection options</a></li><li><a href="#recovery">Automatic Recovery From Network Failures</a></li><li><a href="#unhandled-exceptions">Unhandled Exceptions</a></li><li><a href="#metrics">Metrics and monitoring</a></li><li><a href="#gae-pitfalls">RabbitMQ Java Client on Google App Engine</a></li><li><a href="#cache-pitfalls">Caveats and Limitations</a></li><li><a href="#rpc">The RPC (Request/Reply) Pattern</a></li><li><a href="#tls">TLS Support</a></li></ul></div><div id="related-links"><h4>Related Links</h4><ul><li><a href="/java-client.html">Java Client Downloads</a></li></ul></div></div></div><div class="clear"></div><div class="pageFooter"><div class="container"><div class="rabbit-logo"><a href="/"><img src="/img/RabbitMQ-logo-white.svg" alt="RabbitMQ" /></a></div><ul class="footerNav"><li><a href="/#features">Features</a></li><li><a href="/#getstarted">Get Started</a></li><li><a href="/#support">Support</a></li><li><a href="/#community">Community</a></li><li><a href="/documentation.html">Docs</a></li><li><a href="/blog/">Blog</a></li></ul><a id="s1p-promo" href="https://springoneplatform.io/?utm_source=rabbitmq&amp;utm_medium=tile-web-banner&amp;utm_campaign=s1p-registration-promo" target="_blank"><img src="/img/banner-s1p.png" /></a><p id="copyright">
          Copyright © 2007-Present <a href="https://pivotal.io/">Pivotal Software</a>, Inc. All rights reserved.
          <a href="https://pivotal.io/terms-of-use">Terms of Use</a>,
          <a href="https://pivotal.io/privacy-policy">Privacy</a> and
          <a href="/trademark-guidelines.html">Trademark Guidelines</a></p></div></div></div><script type="text/javascript" src="/js/highlight.pack.js"></script><script type="text/javascript">
        // code highlighting
        onDOMReady(function() {
          document.querySelectorAll(".sourcecode").forEach(function(el) {
            hljs.highlightBlock(el);
          });
        });
      </script></body>
</html>
