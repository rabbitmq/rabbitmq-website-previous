<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="googlebot" content="NOODP" /><meta name="google-site-verification" content="nSYeDgyKM9mw5CWcZuD0xu7iSWXlJijAlg9rcxVOYf4" /><meta name="google-site-verification" content="6UEaC3SWhpGQvqRnSJIEm2swxXpM5Adn4dxZhFsNdw0" /><meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="viewport" name="viewport" /><link href="https://fonts.googleapis.com/css?family=Raleway:400,500,600,700" rel="stylesheet" /><link rel="stylesheet" href="/css/rabbit.css" type="text/css" /><link rel="stylesheet" href="/css/highlightjs_style.css" type="text/css" /><!--[if IE 6]>
      <link rel="stylesheet" href="/css/rabbit-ie6.css" type="text/css" />
      <![endif]--><link rel="icon" type="/image/vnd.microsoft.icon" href="/favicon.ico" /><link rel="stylesheet" href="/css/tutorial.css" type="text/css" /><script type="text/javascript" src="/js/site.js"></script><script type="text/javascript" src="/js/ga-bootstrap.js"></script><title>RabbitMQ - Highly Available (Mirrored) Queues</title>
    
  </head>
  <body id="ha"><div id="outerContainer"><div class="container"><div class="rabbit-logo"><a href="/"><img src="/img/RabbitMQ-logo.svg" alt="RabbitMQ" /></a></div><a class="btn menubtn" onclick="showHide()">Menu <img src="/img/carrot-down-white.svg" /></a><div class="mobilemenuicon" onclick="showHide()"><img src="/img/mobile-menu-icon.svg" /></div><div id="nav"><ul id="mainNav"><li><a href="/#features">Features</a></li><li><a href="/#getstarted">Get Started</a></li><li><a href="/#support">Support</a></li><li><a href="/#community">Community</a></li><li><a href="/documentation.html">Docs</a></li><li><a href="/blog/">Blog</a></li></ul></div></div><div class="nav-separator"></div><div id="innerContainer" class="container"><div id="left-content"><h1>Highly Available (Mirrored) Queues</h1>
      <div class="docSection"><a name="overview" id="overview"></a>
        <p>
          By default, queues within a RabbitMQ cluster are located on
          a single node (the node on which they were first
          declared). This is in contrast to exchanges and bindings,
          which can always be considered to be on all nodes. Queues
          can optionally be made <i>mirrored</i> across multiple
          nodes. Each mirrored queue consists of one <i>master</i> and
          one or more <i>mirrors</i>, with the oldest mirror being
          promoted to the new master if the old master disappears for
          any reason.
        </p>
        <p>
          Messages published to the queue are replicated to all
          mirrors. Consumers are connected to the master regardless of
          which node they connect to, with mirrors dropping messages
          that have been acknowledged at the master. Queue mirroring
          therefore enhances availability, but does not distribute
          load across nodes (all participating nodes each do all the
          work).
        </p>
        <p>
          This solution requires a RabbitMQ cluster, which means that
          it will not cope seamlessly with network partitions within
          the cluster and, for that reason, is not recommended for use
          across a WAN (though of course, clients can still connect
          from as near and as far as needed).
        </p>
        <p>
          There are multiple terms commonly used to identify primary
          and secondary replicas in a distributed system. This guide
          typically uses "master" to refer to the primary replica of a
          queue and "mirror" for secondary replicas.  However, you
          will find "slave" used here and there. This is because
          RabbitMQ CLI tools historically have been using the term
          "slave" to refer to secondaries. Therefore both terms are
          currently used interchangeably but we'd like to eventually
          get rid of the legacy terminology.
        </p>
      </div>

      <div class="docSection"><a name="ways-to-configure" id="ways-to-configure"></a>
        <h2 class="docHeading">How Mirroring is Configured</h2>

        <p>
          Mirroring parameters are configured using <a href="/parameters.html#policies">policies</a>. A policy matches
          one or more queues by name (using a regular expression pattern) and
          contains a definition (a map of optional arguments) that are added to the total set of
          properties of the matching queues.
          Please see <a href="/parameters.html#policies">Runtime Parameters and Policies</a>
          for more information on policies.
        </p>
      </div>

      <div class="docSection"><a name="mirroring-arguments" id="mirroring-arguments"></a>
        <h2 class="docHeading">Queue Arguments that Control Mirroring</h2>
        <p>
          As we've covered above, queues have mirroring enabled
          via <a href="parameters.html#policies">policy</a>. Policies
          can change at any time; it is valid to create a non-mirrored
          queue, and then make it mirrored at some later point (and
          vice versa). There is a difference between a non-mirrored
          queue and a mirrored queue which does not have any mirrors -
          the former lacks the extra mirroring infrastructure and will
          likely provide higher throughput.
        </p>
        <p>
          You should be aware of the behaviour
          of <a href="#unsynchronised-mirrors">adding mirrors to a
          queue</a>.
        </p>
        <p>
          To cause queues to become mirrored, you need to create a
          policy which matches them and sets policy
          keys <span class="code ">ha-mode</span> and
          (optionally) <span class="code ">ha-params</span>. The following table
          explains the options for these keys:
        </p>

        <table>
          <tr>
            <th><span class="code ">ha-mode</span></th>
            <th><span class="code ">ha-params</span></th>
            <th>Result</th>
          </tr>
          <tr>
            <td><span class="code ">all</span></td>
            <td>(absent)</td>
            <td>
              Queue is mirrored across all nodes in the
              cluster. When a new node is added to the cluster, the
              queue will be mirrored to that node.
            </td>
          </tr>
          <tr>
            <td><span class="code ">exactly</span></td>
            <td><i>count</i></td>
            <td>
              Number of queue instances in the cluster.

              A <i>count</i> value of 1 means just the queue master, with no
              mirrors. If the node running the queue master becomes
              unavailable, the queue will become unavailable.

              A <i>count</i> value of 2 means 1 queue master and 1 queue
              mirror. If the node running the queue master becomes unavailable,
              the queue mirror will be automatically promoted to master. In
              conclusion: <span class="code ">NumberOfQueueMirrors = NumberOfNodes - 1</span>.

              If there are fewer than <i>count</i> nodes in the cluster, the
              queue is mirrored to all nodes. If there are more than
              <i>count</i> nodes in the cluster, and a node containing a mirror
              goes down, then a new mirror will be created on another node. Use
              of <span class="code ">exactly</span> mode with <a href="#cluster-shutdown">
                <span class="code ">"ha-promote-on-shutdown": "always"</span></a> can be
              dangerous since queues can migrate across a cluster and become
              unsynced as it is brought down.
            </td>
          </tr>
          <tr>
            <td><span class="code ">nodes</span></td>
            <td><i>node names</i></td>
            <td>
              Queue is mirrored to the nodes listed in <i>node
              names</i>. Node names are the Erlang node names as they
              appear in <span class="code ">rabbitmqctl cluster_status</span>; they
              usually have the form "<tt>rabbit@hostname</tt>". If
              any of those node names are not a part of the cluster,
              this does not constitute an error. If none of the nodes
              in the list are online at the time when the queue is
              declared then the queue will be created on the node that
              the declaring client is connected to.
            </td>
          </tr>
        </table>

        <p>
          Whenever the HA policy for a queue changes it will endeavour
          to keep its existing mirrors as far as this fits with the new
          policy.
        </p>

        <h3 id="replication-factor">To How Many Nodes to Mirror?</h3>
        <p>
          Note that mirroring to all queues is the most conservative option
          and is unnecessary in many cases. For clusters of 3 and more nodes
          it is recommended to mirror to a quorum (the majority) of nodes,
          e.g. 2 nodes in a 3 node cluster or 3 nodes in a 5 node cluster.
          Since some data can be inherently transient or very time sensitive,
          it can be perfectly reasonable to use a lower number of mirrors
          for some queues (or even not use any mirroring).
        </p>
      </div>

      <div class="docSection"><a name="master-migration-data-locality" id="master-migration-data-locality"></a>
        <h2 class="docHeading">Queue Masters, Master Migration, Data Locality</h2>

        <h3 id="queue-master-location">Queue Master Location</h3>
        <p>
          Every queue in RabbitMQ has a home node. That node is called
          <em>queue master</em>. All queue operations go through the master
          first and then are replicated to mirrors. This is necessary to
          guarantee FIFO ordering of messages.
        </p>
        <p>
          Queue masters can be distributed between nodes using several
          strategies. Which strategy is used is controlled in three ways,
          namely, using the <span class="code ">x-queue-master-locator</span> queue
          declare argument, setting the <span class="code ">queue-master-locator</span>
          policy key or by defining the <span class="code ">queue_master_locator</span>
          key in <a href="configure.html#configuration-file">
          <span class="code ">the configuration file</span></a>. Here are the possible
          strategies and how to set them:

          <ul>
            <li>Pick the node hosting the minimum number of masters:
            <span class="code ">min-masters</span></li>
            <li>Pick the node the client that declares the queue is
            connected to: <span class="code ">client-local</span></li>
            <li>Pick a random node: <span class="code ">random</span></li>
          </ul>
        </p>

        <h3>"nodes" Policy and Migrating Masters</h3>

        <p>
          Note that setting or modifying a "nodes" policy can cause
          the existing master to go away if it is not listed in the
          new policy. In order to prevent message loss, RabbitMQ will
          keep the existing master around until at least one other
          mirror has synchronised (even if this is a long
          time). However, once synchronisation has occurred things will
          proceed just as if the node had failed: consumers will be
          disconnected from the master and will need to reconnect.
        </p>
        <p>
          For example, if a queue is on <span class="code ">[A B]</span>
          (with <span class="code ">A</span> the master), and you give it
          a <span class="code ">nodes</span> policy telling it to be on
          <span class="code ">[C D]</span>, it will initially end up on
          <span class="code ">[A C D]</span>. As soon as the queue synchronises on its new
          mirrors <span class="code ">[C D]</span>, the master on <span class="code ">A</span>
          will shut down.
        </p>

        <h3>Exclusive Queues</h3>

        <p>
          Exclusive queues will be deleted when the connection that
          declared them is closed. For this reason, it is not useful
          for an exclusive queue to be mirrored (or durable for that
          matter) since when the node hosting it goes down, the
          connection will close and the queue will need to be deleted
          anyway.
        </p>

        <p>
          For this reason, exclusive queues are never mirrored (even
          if they match a policy stating that they should be). They
          are also never durable (even if declared as such).
        </p>
      </div>

      <div class="docSection"><a name="examples" id="examples"></a>
        <h2 class="docHeading">Examples</h2>

        <p>
          The following example declares a policy named <span class="code ">ha-all</span> which matches
          the queues whose names begin with
          "<span class="code ">ha.</span>" and configures mirroring to all nodes in the cluster (see <a href="#replication-factor">To How Many Nodes to Mirror?</a> above):
        </p>

        <table>
          <tr>
            <th>rabbitmqctl</th>
            <td>
              <pre>rabbitmqctl set_policy ha-all "^ha\." '{"ha-mode":"all"}'</pre>
            </td>
          </tr>
          <tr>
            <th>rabbitmqctl (Windows)</th>
            <td>
              <pre>rabbitmqctl set_policy ha-all "^ha\." "{""ha-mode"":""all""}"</pre>
            </td>
          </tr>
          <tr>
            <th>HTTP API</th>
            <td>
              <pre>PUT /api/policies/%2f/ha-all {"pattern":"^ha\.", "definition":{"ha-mode":"all"}}</pre>
            </td>
          </tr>
          <tr>
            <th>Web UI</th>
            <td>
              <ul>
                <li>
                  Navigate to Admin &gt; Policies &gt; Add / update a
                  policy.
                </li>
                <li>
                  Enter "ha-all" next to Name, "^ha\." next to Pattern,
                  and "ha-mode" = "all" in the first line next to
                  Policy.
                </li>
                <li>
                  Click Add policy.
                </li>
              </ul>
            </td>
          </tr>
        </table>

        <p>
          Policy where queues whose names begin with
          "<span class="code ">two.</span>" are mirrored to any two nodes in the
          cluster, with <a href="#eager-synchronisation">automatic
          synchronisation</a>:
        </p>

        <table>
          <tr>
            <th>rabbitmqctl</th>
            <td>
              <pre>rabbitmqctl set_policy ha-two "^two\." \
   '{"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"}'</pre>
            </td>
          </tr>
          <tr>
            <th>rabbitmqctl (Windows)</th>
            <td>
              <pre>rabbitmqctl set_policy ha-two "^two\." ^
   "{""ha-mode"":""exactly"",""ha-params"":2,"ha-sync-mode":"automatic"}"</pre>
            </td>
          </tr>
          <tr>
            <th>HTTP API</th>
            <td>
              <pre>PUT /api/policies/%2f/ha-two
{"pattern":"^two\.", "definition":{"ha-mode":"exactly", "ha-params":2,"ha-sync-mode":"automatic"}}</pre>
            </td>
          </tr>
          <tr>
            <th>Web UI</th>
            <td>
              <ul>
                <li>
                  Navigate to Admin &gt; Policies &gt; Add / update a
                  policy.
                </li>
                <li>
                  Enter "ha-two" next to Name and "^two\." next to
                  Pattern.
                </li>
                <li>
                  Enter "ha-mode" = "exactly" in the first line
                  next to Policy, then "ha-params" = 2 in the second
                  line, then "ha-sync-mode" = "automatic" in the third,
                  and set the type on the second line to "Number".
                </li>
                <li>
                  Click Add policy.
                </li>
              </ul>
            </td>
          </tr>
        </table>

        <p>
          Policy where queues whose names begin with
          "<span class="code ">nodes.</span>" are mirrored to specific nodes in the
          cluster:
        </p>

        <table>
          <tr>
            <th>rabbitmqctl</th>
            <td>
              <pre>rabbitmqctl set_policy ha-nodes "^nodes\." \
   '{"ha-mode":"nodes","ha-params":["rabbit@nodeA", "rabbit@nodeB"]}'</pre>
            </td>
          </tr>
          <tr>
            <th>rabbitmqctl (Windows)</th>
            <td>
              <pre>rabbitmqctl set_policy ha-nodes "^nodes\." ^
   "{""ha-mode"":""nodes"",""ha-params"":[""rabbit@nodeA"", ""rabbit@nodeB""]}"</pre>
            </td>
          </tr>
          <tr>
            <th>HTTP API</th>
            <td>
              <pre>PUT /api/policies/%2f/ha-nodes
{"pattern":"^nodes\.", "definition":{"ha-mode":"nodes", "ha-params":["rabbit@nodeA", "rabbit@nodeB"]}</pre>
            </td>
          </tr>
          <tr>
            <th>Web UI</th>
            <td>
              <ul>
                <li>
                  Navigate to Admin &gt; Policies &gt; Add / update a
                  policy.
                </li>
                <li>
                  Enter "ha-nodes" next to Name and "^nodes\." next to
                  Pattern.
                </li>
                <li>
                  Enter "ha-mode" = "nodes" in the first line next to
                  Policy, then "ha-params" in the second line, set the
                  second line's type to "List", and then enter
                  "rabbit@nodeA" and "rabbit@nodeB" in the sublist which
                  appears.
                </li>
                <li>
                  Click Add policy.
                </li>
              </ul>
            </td>
          </tr>
        </table>
      </div>

      <div class="docSection"><a name="behaviour" id="behaviour"></a>
        <h2 class="docHeading">Mirrored Queue Implementation and Semantics</h2>
        <p>
          As discussed, for each mirrored queue there is one
          <i>master</i> and several <i>mirrors</i>, each on a
          different node. The mirrors apply the operations that occur
          to the master in exactly the same order as the master and
          thus maintain the same state. All actions other than
          publishes go only to the master, and the master then
          broadcasts the effect of the actions to the mirrors. Thus
          clients consuming from a mirrored queue are in fact
          consuming from the master.
        </p>
        <p>
          Should a mirror fail, there is little to be done other than
          some bookkeeping: the master remains the master and no
          client need take any action or be informed of the failure.
          Note that mirror failures may not be detected immediately and
          the interruption of the per-connection flow control mechanism
          can delay message publication. The details are described
          <a href="nettick.html">here</a>.
        </p>
        <p>
          If the master fails, then one of the mirrors will be promoted to
          master as follows:
          <ol class="plain">
            <li>
              The longest running mirror is promoted to master, the assumption
              being that it is most likely to be fully synchronised with the
              master. If there is no mirror that is <a href="#unsynchronised-mirrors">synchronised</a> with the
              master, messages that only existed on master will be lost.
            </li>
            <li>
              The mirror considers all previous consumers to have been abruptly
              disconnected. It requeues all messages that have been delivered
              to clients but are pending acknowledgement. This can include
              messages for which a client has issued acknowledgements, say, if
              an acknowledgement was either lost on the wire before reaching the
              node hosting queue master, or it was lost when broadcast from the master to the
              mirrors. In either case, the new master has no choice but to
              requeue all messages that it has not seen acknowledgements for.
            </li>
            <li>
              Consumers that have requested to be notified when a queue fails
              over <a href="#cancellation">will be notified of cancellation</a>.
            </li>
            <li>
              As a result of the requeuing, clients that re-consume from the
              queue <b>must</b> be aware that they are likely to subsequently
              receive messages that they have already received.
            </li>
            <li>
              As the chosen mirror becomes the master, no messages that are
              published to the mirrored queue during this time will be lost
              (barring subsequent failures on the promoted node).
              Messages published to a node that hosts queue mirror are routed
              to the queue master and then replicated to all mirrors. Should the master fail,
              the messages continue to be sent to the mirrors and will be added
              to the queue once the promotion of a mirror to the master
              completes.
            </li>
            <li>
              Messages published by clients using <a href="confirms.html">publisher confirms</a> will still be
              confirmed even if the master (or any mirrors) fail
              between the message being published and a confirmation received
              by the publisher. From the point of view of the publisher,
              publishing to a mirrored queue is no different from publishing to
              a non-mirrored one.
            </li>
          </ol>
        </p>
        <p>
          If you are consuming from a mirrored queue with
          <span class="code ">noAck=true</span> (i.e. the client is not sending message
          acknowledgements), then messages can be lost. This is no different
          from the norm of course: the broker considers a message
          <em>acknowledged</em> as soon as it has been sent to a
          <span class="code ">noAck=true</span> consumer. Should the client disconnect
          abruptly, the message may never be received. In the case of a
          mirrored queue, should the master die, messages that are in-flight on
          their way to <span class="code ">noAck=true</span> consumers may never be received
          by those clients, and will not be requeued by the new master. Because
          of the possibility that the consuming client is connected to a node
          that survives, the <a href="#cancellation">consumer cancellation
            notification</a> is useful to identify when such events may have
          occurred. Of course, in practise, if you care about not losing
          messages, then you are advised to consume with
          <span class="code ">noAck=false</span>.
        </p>
        <div class="docSubsection"><a name="confirms-transactions" id="confirms-transactions"></a>
          <h3 class="docHeading">Publisher Confirms and Transactions</h3>
          <p>
            Mirrored queues support both <a href="confirms.html">publisher confirms</a> and
            <a href="specification.html#tx">transactions</a>. The
            semantics chosen are that in the case of both confirms and
            transactions, the action spans all mirrors of the
            queue. So in the case of a transaction, a
            <span class="code ">tx.commit-ok</span> will only be returned to a
            client when the transaction has been applied across all
            mirrors of the queue. Equally, in the case of publisher
            confirms, a message will only be confirmed to the
            publisher when it has been accepted by all of the
            mirrors. It is correct to think of the semantics as being
            the same as a message being routed to multiple normal
            queues, and of a transaction with publications within
            that similarly are routed to multiple queues.
          </p>
        </div>
        <div class="docSubsection"><a name="flow-control" id="flow-control"></a>
          <h3 class="docHeading">Flow Control</h3>
          <p>
            RabbitMQ uses a credit-based algorithm to <a href="memory.html#per-connection">limit the rate of
            message publication</a>.  Publishers are permitted to
            publish when they receive credit from all mirrors of a
            queue.  Credit in this context means permission to
            publish.  Mirrors that fail to issue credit can cause
            publishers to stall. Publishers will remain blocked until
            all mirrors issue credit or until the remaining nodes
            consider the mirror to be disconnected from the cluster.
            Erlang detects such disconnections by periodically sending
            a tick to all nodes. The tick interval can be controlled
            with the <a href="nettick.html">net_ticktime</a>
            configuration setting.
          </p>
        </div>
        <div class="docSubsection"><a name="cancellation" id="cancellation"></a>
          <h3 class="docHeading">Master Failures and Consumer Cancellation</h3>
          <p>
            Clients that are consuming from a mirrored queue may wish
            to know that the queue from which they have been consuming
            has failed over. When a mirrored queue fails over,
            knowledge of which messages have been sent to which
            consumer is lost, and therefore all unacknowledged
            messages are redelivered with the <span class="code ">redelivered</span>
            flag set. Consumers may wish to know this is going to
            happen.
          </p>
          <p>
            If so, they can consume with the argument
            <span class="code ">x-cancel-on-ha-failover</span> set to
            <span class="code ">true</span>. Their consuming will then be cancelled
            on failover and a <a href="consumer-cancel.html">consumer
            cancellation notification</a> sent. It is then the
            consumer's responsibility to reissue
            <span class="code ">basic.consume</span> to start consuming again.
          </p>
          <p>
            For example (in Java):
          </p>

          <pre class="sourcecode java">
Channel channel = ...;
Consumer consumer = ...;
Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();
args.put("x-cancel-on-ha-failover", true);
channel.basicConsume("my-queue", false, args, consumer);</pre>

          <p>
            This creates a new consumer with the argument set.
          </p>
        </div>

      </div>



      <div class="docSection"><a name="unsynchronised-mirrors" id="unsynchronised-mirrors"></a>
        <h2 class="docHeading">Unsynchronised Mirrors</h2>
        <p>
          A node may join a cluster at any time. Depending on the
          configuration of a queue, when a node joins a cluster,
          queues may add a mirror on the new node. At this point, the
          new mirror will be empty: it will not contain any existing
          contents of the queue. Such a mirror will receive new
          messages published to the queue, and thus over time will
          accurately represent the tail of the mirrored queue. As
          messages are drained from the mirrored queue, the size of
          the head of the queue for which the new mirror is missing
          messages, will shrink until eventually the mirror's contents
          precisely match the master's contents. At this point, the
          mirror can be considered fully synchronised, but it is
          important to note that this has occurred because of actions
          of clients in terms of draining the pre-existing head of the
          queue.
        </p>
        <p>
          A newly added mirror provides no additional form of
          redundancy or availability of the queue's contents that
          existed before the mirror was added, unless the queue has
          been explicitly synchronised. Since the queue becomes
          unresponsive while explicit synchronisation is occurring, it
          is preferable to allow active queues from which messages are
          being drained to synchronise naturally, and only explicitly
          synchronise inactive queues.
        </p>

        <p>
          You can determine which mirrors are synchronised with the
          following rabbitmqctl invocation:
        </p>
        <pre class="sourcecode bash">rabbitmqctl list_queues name slave_pids synchronised_slave_pids</pre>
        <p>
          You can manually synchronise a queue with:
        </p>
        <pre class="sourcecode bash">rabbitmqctl sync_queue <i>name</i></pre>
        <p>
          And you can cancel synchronisation with:
        </p>
        <pre class="sourcecode bash">rabbitmqctl cancel_sync_queue <i>name</i></pre>
        <p>
          These features are also available through the management plugin.
        </p>

        <div class="docSubsection"><a name="start-stop" id="start-stop"></a>
          <h3 class="docHeading">Stopping nodes and synchronisation</h3>
          <p>
            If you stop a RabbitMQ node which contains the master of a
            mirrored queue, some mirror on some other node will be
            promoted to the master (assuming there is a synchronised mirror;
            see <a href="#cluster-shutdown">below</a>). If you
            continue to stop nodes then you will reach a point where a
            mirrored queue has no more mirrors: it exists only on one
            node, which is now its master.  If the mirrored queue was
            declared <i>durable</i> then, if its last remaining node is
            shutdown, durable messages in the queue will survive the
            restart of that node. In general, as you restart other
            nodes, if they were previously part of a mirrored queue then
            they will rejoin the mirrored queue.
          </p>
          <p>
            However, there is currently no way for a mirror to know
            whether or not its queue contents have diverged from the
            master to which it is rejoining (this could happen during a
            network partition, for example). As such, when a mirror
            rejoins a mirrored queue, it throws away any durable local
            contents it already has and starts empty. Its behaviour is
            at this point the same as if it were a <a href="#unsynchronised-mirrors">new node joining the
            cluster</a>.
          </p>
        </div>

        <div class="docSubsection"><a name="cluster-shutdown" id="cluster-shutdown"></a>
          <h3 class="docHeading">Stopping Master Nodes with Only Unsynchronised Mirrors</h3>
          <p>
            It's possible that when you shut down a master node that
            all available mirrors are unsynchronised. A common
            situation in which this can occur is rolling cluster
            upgrades. By default, RabbitMQ will refuse to fail over to
            an unsynchronised mirror on controlled master shutdown
            (i.e. explicit stop of the RabbitMQ service or shutdown of
            the OS) in order to avoid message loss; instead the entire
            queue will shut down as if the unsynchronised mirrors were
            not there. An uncontrolled master shutdown (i.e. server or
            node crash, or network outage) will still trigger a
            failover even to an unsynchronised mirror.
          </p>
          <p>
            If you would prefer to have master nodes fail over to
            unsynchronised mirrors in all circumstances (i.e. you would
            choose availability of the queue over avoiding message
            loss) then you can set the
            <span class="code ">ha-promote-on-shutdown</span> policy key to
            <span class="code ">always</span> rather than its default value of
            <span class="code ">when-synced</span>.
          </p>

        </div>

        <div class="docSubsection"><a name="promotion-while-down" id="promotion-while-down"></a>
          <h3 class="docHeading">Loss of a Master While All Mirrors are Stopped</h3>
          <p>
            It is possible to lose the master for a queue while all
            mirrors for the queue are shut down. In normal operation
            the last node for a queue to shut down will become the
            master, and we want that node to still be the master when
            it starts again (since it may have received messages that
            no other mirror saw).
          </p>

          <p>
            However, when you invoke
            <span class="code ">rabbitmqctl forget_cluster_node</span>, RabbitMQ will attempt to find
            a currently stopped mirror for each queue which has its
            master on the node we are forgetting, and "promote" that
            mirror to be the new master when it starts up again. If
            there is more than one candidate, the most recently
            stopped mirror will be chosen.
          </p>

          <p>
            It's important to understand that RabbitMQ can only
            promote <b>stopped</b> mirrors during
            <span class="code ">forget_cluster_node</span>, since any mirrors that
            are started again will clear out their contents as
            described at "<a href="#start-stop">stopping nodes and
            synchronisation</a>" above. Therefore when removing a lost
            master in a stopped cluster, you must invoke
            <span class="code ">rabbitmqctl forget_cluster_node</span> <i>before</i>
            starting mirrors again.
          </p>
        </div>


        <div class="docSubsection"><a name="batch-sync" id="batch-sync"></a>
          <h3 class="docHeading">Batch Synchronization</h3>

          <p>
            Since RabbitMQ 3.6.0, masters perform synchronisation in
            batches. Batch can be configured via the
            <span class="code ">ha-sync-batch-size</span> queue argument.  Earlier
            versions will will synchronise <span class="code ">1</span> message at a
            time by default.  By synchronising messages in batches,
            the synchronisation process can be sped up considerably.
          </p>

          <p>
            To choose the right value for
            <span class="code ">ha-sync-batch-size</span> you need to consider:
            <ul class="plain">
              <li>
                average message size
              </li>
              <li>
                network throughput between RabbitMQ nodes
              </li>
              <li>
                net_ticktime value
              </li>
            </ul>
          </p>
          <p>
            For example, if you set <span class="code ">ha-sync-batch-size</span> to
            <span class="code ">50000</span> messages, and each message in the
            queue is 1KB, then each synchronisation message between nodes
            will be ~49MB. You need to make sure that your network
            between queue mirrors can accomodate this kind of traffic. If the
            network takes longer than <a href="nettick.html">net_ticktime</a>
            to send one batch of messages, then nodes in the cluster could
            think they are in the presence of a network partition.
          </p>

          <h3 id="eager-synchronisation">Configuring Synchronisation</h3>

          <p>
            Let's start with the most important aspect of queue
            synchronisation: <em>while a queue is being synchronised, all other
              queue operations will be blocked</em>. Depending on multiple
            factors, a queue might be blocked by synchronisation for many
            minutes or hours, and in extreme cases even days.
          </p>

          <p>
            Queue synchronisation can be configured as follows:

            <ul class="plain">
              <li>
                <span class="code ">ha-sync-mode: manual</span> - this is the default mode.
                A new queue mirror will not receive existing messages, it will
                only receive new messages. The new queue mirror will become an
                exact replica of the master over time, once consumers have
                drained messages that only exist on the master. If the master
                queue fails before all unsychronised messages are drained,
                those messages will be lost. You can fully synchronise a queue
                manually, refer to <a href="#unsynchronised-mirrors">unsynchronised mirrors</a>
                section for details.
              </li>
              <li>
                <span class="code ">ha-sync-mode: automatic</span> - a queue will
                automatically synchronise when a new mirror joins. It is worth
                reiterating that queue synchronisation is a blocking operation.
                If queues are small, or you have a fast network between
                RabbitMQ nodes and the <span class="code ">ha-sync-batch-size</span> was
                optimised, this is a good choice.
              </li>
            </ul>
          </p>

        </div>
      </div>
  </div><div id="right-nav"><div id="in-this-section"><h4>In This Section</h4><ul>
     <li><a href="/admin-guide.html" class="selected">Server Documentation</a><ul>
       <li><a href="/configure.html">Configuration</a></li>
       <li><a href="/ssl.html">TLS/SSL Support</a></li>
       <li><a href="/distributed.html">Distributed RabbitMQ</a></li>
       <li><a href="/reliability.html">Reliable Delivery</a></li>
       <li><a href="/clustering.html">Clustering</a></li>
       <li><a href="/vhosts.html">Virtual Hosts</a></li>
       <li><a href="/ha.html" class="selected">High Availability</a></li>
       <li><a href="/pacemaker.html">High Availability (pacemaker)</a></li>
       <li><a href="/access-control.html">Access Control (Authorisation)</a></li>
       <li><a href="/authentication.html">Authentication Mechanisms</a></li>
       <li><a href="/ldap.html">LDAP</a></li>
       <li><a href="/production-checklist.html">Production Checklist</a></li>
       <li><a href="/alarms.html">Alarms</a></li>
       <li><a href="/networking.html">Networking</a></li>
       <li><a href="/memory-use.html">Memory Use</a></li>
       <li><a href="/lazy-queues.html">Lazy Queues</a></li>
       <li><a href="/event-exchange.html">Internal Event Exchange</a></li>
       <li><a href="/firehose.html">Firehose (Message Tracing)</a></li>
       <li><a href="/manpages.html">Manual Pages</a></li>
       <li><a href="/windows-quirks.html">Windows Quirks</a></li>
       
       
       
       
     </ul></li>
     <li><a href="/clients.html">Client Documentation</a></li>
     <li><a href="/plugins.html">Plugins</a></li>
     <li><a href="/news.html">News</a></li>
     <li><a href="/protocol.html">Protocol</a></li>
     <li><a href="/extensions.html">Our Extensions</a></li>
     <li><a href="/build.html">Building</a></li>
     
       <li><a href="/previous.html">Previous Releases</a></li>
     
     <li><a href="/mpl.html">License</a></li>
   </ul></div><div class="in-this-page"><h4>In This Page</h4><ul><li><a href="#overview"></a></li><li><a href="#ways-to-configure">How Mirroring is Configured</a></li><li><a href="#mirroring-arguments">Queue Arguments that Control Mirroring</a></li><li><a href="#master-migration-data-locality">Queue Masters, Master Migration, Data Locality</a></li><li><a href="#examples">Examples</a></li><li><a href="#behaviour">Mirrored Queue Implementation and Semantics</a></li><li><a href="#unsynchronised-mirrors">Unsynchronised Mirrors</a></li></ul></div></div></div><div class="clear"></div><div class="pageFooter"><div class="container"><div class="rabbit-logo"><a href="/"><img src="/img/RabbitMQ-logo-white.svg" alt="RabbitMQ" /></a></div><ul class="footerNav"><li><a href="/#features">Features</a></li><li><a href="/#getstarted">Get Started</a></li><li><a href="/#support">Support</a></li><li><a href="/#community">Community</a></li><li><a href="/documentation.html">Docs</a></li><li><a href="/blog/">Blog</a></li></ul><a id="s1p-promo" href="https://springoneplatform.io/?utm_source=rabbitmq&amp;utm_medium=tile-web-banner&amp;utm_campaign=s1p-registration-promo" target="_blank"><img src="/img/banner-s1p.png" /></a><p id="copyright">
          Copyright Â© 2007-Present <a href="https://pivotal.io/">Pivotal Software</a>, Inc. All rights reserved.
          <a href="https://pivotal.io/terms-of-use">Terms of Use</a>,
          <a href="https://pivotal.io/privacy-policy">Privacy</a> and
          <a href="/trademark-guidelines.html">Trademark Guidelines</a></p></div></div></div><script type="text/javascript" src="/js/highlight.pack.js"></script><script type="text/javascript">
        // code highlighting
        onDOMReady(function() {
          document.querySelectorAll(".sourcecode").forEach(function(el) {
            hljs.highlightBlock(el);
          });
        });
      </script></body>
</html>
